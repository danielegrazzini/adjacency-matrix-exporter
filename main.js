/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const DEFAULT_SETTINGS = {
    csvSeparator: 'ยง',
    folderPath: "/",
};
// !SECTION Matrix Modal
// SECTION SettingsTab
class AdjacencyMatrixExporterSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        // this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        new obsidian.Setting(containerEl)
            .setName("CSV Separator")
            .setDesc(`The value used to separate values between each other. Default separator value is ${DEFAULT_SETTINGS.csvSeparator}.`)
            .addText((text) => text
            .setPlaceholder("Separator")
            .setValue(this.plugin.settings.csvSeparator)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.csvSeparator = value.trim() || DEFAULT_SETTINGS.csvSeparator;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(containerEl)
            .setName("Folder path")
            .setDesc(`The folder path to save generated .csv files. Default is the current vault relative path ${DEFAULT_SETTINGS.folderPath}.`)
            .addText((text) => text
            .setPlaceholder("Folder path")
            .setValue(this.plugin.settings.folderPath)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.folderPath = value.trim() || DEFAULT_SETTINGS.folderPath;
            yield this.plugin.saveSettings();
        })));
        // !SECTION Obsidian Settings
    }
}

class AdjacencyMatrixExporter extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.openMainModal = () => __awaiter(this, void 0, void 0, function* () {
            const files = this.app.vault.getMarkdownFiles();
            new MainModal(this.app, files, this.settings).open();
        });
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("Loading AdjacencyMatrixExporter Maker plugin");
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
            obsidian.addIcon("matrix", `<defs><style>.cls-1{fill:none;}</style></defs><title>CSV</title><path fill="#FFFFFF" points="28 9 26 22 24 9 22 9 24.516 23 27.484 23 30 9 28 9" d="M87.5 28.125L81.25 68.75L75 28.125L68.75 28.125L76.612 71.875L85.888 71.875L93.75 28.125L87.5 28.125Z"/><path fill="#FFFFFF" d="M56.25 71.875h-18.75v-6.25h18.75v-12.5h-12.5a6.256 6.256 0 0 1 -6.25 -6.25v-12.5a6.256 6.256 0 0 1 6.25 -6.25h18.75v6.25h-18.75v12.5h12.5a6.256 6.256 0 0 1 6.25 6.25v12.5a6.256 6.256 0 0 1 -6.25 6.25Z"/><path fill="#FFFFFF" d="M31.25 71.875H12.5a6.256 6.256 0 0 1 -6.25 -6.25V34.375a6.256 6.256 0 0 1 6.25 -6.25h18.75v6.25H12.5v31.25h18.75Z"/><path id="_Transparent_Rectangle_" data-name="&amp;lt;Transparent Rectangle&amp;gt;" class="cls-1" width="32" height="32" d="M0 0H100V100H0V0z"/>`);
            this.addRibbonIcon("matrix", "AdjacencyMatrixExporter", this.openMainModal);
            this.addCommand({
                id: "adjacency-matrix-exporter",
                name: "Open AdjacencyMatrixExporter",
                callback: this.openMainModal,
            });
            this.addSettingTab(new AdjacencyMatrixExporterSettingTab(this.app, this));
        });
    }
    onunload() {
        console.log("unloading AdjacencyMatrixExporter Maker plugin");
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
// SECTION Matrix Modal
class MainModal extends obsidian.Modal {
    constructor(app, files, settings) {
        super(app);
        this.files = [];
        this.files = files;
        this.settings = settings;
    }
    onOpen() {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /*
        const {contentEl} = this;
        const div1 = document.createElement('div');
        div1.textContent = "a. ABSOLUTE: generates a numerical adjacency matrix, in CSV format, where the weights of the edges are given by the number of connections from one note to another";
        contentEl.appendChild(div1);
    
        const hr1 = document.createElement('hr');
        contentEl.appendChild(hr1);
    
        const div2 = document.createElement('div');
        div2.textContent = "b. NORMALIZED: generates a numerical adjacency matrix, in CSV format, where the weight of the edge from note A to note B is divided by the number of total words in note A";
        contentEl.appendChild(div2);
    
        const hr2 = document.createElement('hr');
        contentEl.appendChild(hr2);
        */
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        this.buildHTML();
    }
    updateSeparatorHTML() {
        document.querySelector('.app-csv-separator-value').textContent = this.settings.csvSeparator;
    }
    buildHTML() {
        // Set Title
        const vaultName = this.app.vault.getName();
        this.titleEl.textContent = `Adjacency Matrix Exporter for ${vaultName}`;
        // Create Separator HTML Row
        const separatorRowEl = this.contentEl.createDiv({ cls: "app-csv-separator-row" });
        separatorRowEl.createEl('strong', {
            text: 'Actually the CSV Separator is:   '
        });
        separatorRowEl.createEl('span', {
            cls: 'app-csv-separator-value',
            text: this.settings.csvSeparator
        });
        const changeSeparatorAction = separatorRowEl.createEl('a', {
            text: 'Click here to change it!',
        });
        changeSeparatorAction.addEventListener("click", () => this.openChangeSeparatorModal());
        // Create Actions HTML Row
        const buttonRow = this.contentEl.createDiv({ cls: "app-actions-row" });
        // Export Absolute Button
        const exportCsvButtonAbsolute = buttonRow.createEl("button", {
            text: "Export CSV Absolute Matrix",
        });
        exportCsvButtonAbsolute.addEventListener("click", () => this.exportCsvAbsolute());
        // Export Normalized Button
        const exportCsvButtonNormalized = buttonRow.createEl("button", {
            text: "Export CSV Normalized Matrix",
        });
        exportCsvButtonNormalized.addEventListener("click", () => this.exportCsvNormalized());
    }
    // User can choose the CSV separator 
    openChangeSeparatorModal() {
        // create new instance of separator modal
        this.changeSeparatorModalRef = new ChangeSeparatorModal(this.app, this.settings.csvSeparator, DEFAULT_SETTINGS.csvSeparator);
        // on close: save new separator settings and update html
        this.changeSeparatorModalRef.onClose = () => {
            this.settings.csvSeparator = this.changeSeparatorModalRef.getStoredValue() || DEFAULT_SETTINGS.csvSeparator;
            this.updateSeparatorHTML();
        };
        // open separator dialog
        this.changeSeparatorModalRef.open();
    }
    // export Absolute matrix scores as CSV
    exportCsvAbsolute() {
        const app = this.app;
        const settings = this.settings;
        const files = this.files;
        console.log("Save CSV!");
        const symbol = this.settings.csvSeparator;
        const folderPath = settings.folderPath === "" ? "/" : settings.folderPath;
        const now = window.moment().format("YYYY-MM-DD HHmmss");
        const filePath = `${folderPath}/Absolute matrix ${now}.csv`;
        const size = files.length;
        let data = "";
        // print CSV header
        for (let j = size - 1; j >= 0; j--) {
            data += symbol + files[j].basename;
        }
        data += "\n";
        for (let i = size - 1; i >= 0; i--) {
            data += files[i].basename + symbol;
            for (let j = size - 1; j >= 0; j--) {
                const n_links = app.metadataCache.resolvedLinks[files[i].path][files[j].path];
                data += isNaN(n_links) ? 0 : n_links;
                if (j > 0)
                    data += symbol;
            }
            data += "\n";
        }
        console.log("Separator used is, " + symbol);
        console.log(data);
        app.vault.create(filePath, data);
        new obsidian.Notice(`CSV Absolute matrix saved:\n${filePath}`);
    }
    // export Normalized matrix scores as CSV
    // This Matrix is Normalized by the counter word of an origine note 
    // Add a function to calculate the total words in a note!
    exportCsvNormalized() {
        const app = this.app;
        const settings = this.settings;
        const files = this.files;
        console.log("Save CSV!");
        const symbol = this.settings.csvSeparator;
        const folderPath = settings.folderPath === "" ? "/" : settings.folderPath;
        const now = window.moment().format("YYYY-MM-DD HHmmss");
        const filePath = `${folderPath}/Normalized matrix ${now}.csv`;
        const size = files.length;
        new obsidian.Notice(`CSV Normalized matrix saved:\n${filePath}`);
        console.log("Separator used is, " + symbol);
        // New function that counts the words of the notes
        // done via an async function
        const vault = app.vault;
        function countWordsInAllNotes() {
            return __awaiter(this, void 0, void 0, function* () {
                // I get the list of all notes in the Vault
                const allNotes = vault.getMarkdownFiles();
                const totalNotes = allNotes.length;
                // I sort the notes by file name
                allNotes.sort((a, b) => b.basename.localeCompare(a.basename));
                // I create an array to store the word counts
                const wordCounts = [];
                // Loop through each note
                for (const i in allNotes) {
                    const note = allNotes[i];
                    const content = yield vault.cachedRead(note);
                    const wordMatches = content.match(/\b\w+\b/g);
                    const wordCount = wordMatches ? wordMatches.length : 0;
                    // I create an array with the word count and fill it in each column of the row
                    wordCounts.push(new Array(totalNotes).fill(wordCount));
                }
                return wordCounts;
            });
        }
        // I print the matrix obtained by dividing the link weights 
        // between notes with the word count of the notes 
        function main() {
            return __awaiter(this, void 0, void 0, function* () {
                const wordCountsMatrix = yield countWordsInAllNotes();
                ////////////////////////////////////////////////////////////////////////////////////
                /* code that prints the note word count matrix if you make a control on your console
            
                let datawords = "\t";
            
                for (let j = size-1; j >= 0; j--) {
                  datawords += "\t" + files[j].basename;
                }
                datawords += "\n";
            
                for (let i = size-1; i >= 0; i--) {
                  datawords += files[i].basename + "\t\t";
                  for (let j = size-1; j >= 0; j--) {
                    const n_words = wordCountsMatrix[i][j];
                    datawords += isNaN(n_words) ? 0 : n_words;
                    if (j > 0)
                      datawords += "\t\t";
                  }
                  datawords += "\n";
                }
            
                console.log(datawords);
                */
                ///////////////////////////////////////////////////////////////////////////////////
                let data = "";
                // print CSV Normalized matrix header
                for (let j = size - 1; j >= 0; j--) {
                    data += symbol + files[j].basename;
                }
                data += "\n";
                for (let i = size - 1; i >= 0; i--) {
                    data += files[i].basename + symbol;
                    for (let j = size - 1; j >= 0; j--) {
                        let n_links = app.metadataCache.resolvedLinks[files[i].path][files[j].path] / (wordCountsMatrix[i][j]);
                        data += isNaN(n_links) ? 0 : String(n_links).replace(".", ",");
                        if (j > 0)
                            data += symbol;
                    }
                    data += "\n";
                }
                console.log(data);
                app.vault.create(filePath, data);
            });
        }
        main();
        // End async function countWordsInAllNotes      
    }
    onClose() {
        let { contentEl } = this;
        contentEl.empty();
    }
}
class ChangeSeparatorModal extends obsidian.Modal {
    constructor(app, currentValue, defaultValue) {
        super(app);
        this.currentValue = currentValue;
        this.defaultValue = defaultValue;
    }
    onOpen() {
        this.titleEl.textContent = `Change CSV Separator`;
        let content = this.contentEl;
        // customize the contents of the user box
        content.innerHTML = `
      <p>
        Choose your favourite char to separate .csv data.<br>
        The default char is " ${this.defaultValue} ".<br>
        If you want to change it, insert your char below and press OK.
      </p>
    `;
        // adds an input field
        this.userInput = content.createEl('input', { type: 'text' });
        this.userInput.value = this.currentValue;
        content.appendChild(this.userInput);
        // adds a button to confirm the input
        const confirmButton = content.createEl('button');
        confirmButton.textContent = 'OK';
        confirmButton.onclick = () => this.onConfirm();
        content.appendChild(confirmButton);
    }
    onConfirm() {
        // I get the value entered by the user
        const userInputValue = this.userInput.value;
        // This is the value to use within 'Export to CSV'
        console.log('Input User: ', userInputValue);
        this.currentValue = this.userInput.value.trim();
        // Closes the box
        this.close();
    }
    getStoredValue() {
        return this.currentValue;
    }
}

module.exports = AdjacencyMatrixExporter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIkFkamFjZW5jeU1hdHJpeEV4cG9ydGVyU2V0dGluZ1RhYi50cyIsIm1haW4udHMiXSwic291cmNlc0NvbnRlbnQiOm51bGwsIm5hbWVzIjpbIlBsdWdpblNldHRpbmdUYWIiLCJTZXR0aW5nIiwiUGx1Z2luIiwiYWRkSWNvbiIsIk1vZGFsIiwiTm90aWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0dBO0FBQ08sU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFO0FBQzdELElBQUksU0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxLQUFLLFlBQVksQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxVQUFVLE9BQU8sRUFBRSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0FBQ2hILElBQUksT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLEVBQUUsTUFBTSxFQUFFO0FBQy9ELFFBQVEsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtBQUNuRyxRQUFRLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtBQUN0RyxRQUFRLFNBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsRUFBRTtBQUN0SCxRQUFRLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxVQUFVLElBQUksRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM5RSxLQUFLLENBQUMsQ0FBQztBQUNQLENBQUM7QUFnTUQ7QUFDdUIsT0FBTyxlQUFlLEtBQUssVUFBVSxHQUFHLGVBQWUsR0FBRyxVQUFVLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQ3ZILElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDL0IsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFVBQVUsR0FBRyxVQUFVLEVBQUUsQ0FBQyxDQUFDO0FBQ3JGOztBQ3RUTyxNQUFNLGdCQUFnQixHQUFvQztBQUMvRCxJQUFBLFlBQVksRUFBRSxHQUFHO0FBQ2pCLElBQUEsVUFBVSxFQUFFLEdBQUc7Q0FDaEIsQ0FBQztBQUVGO0FBQ0E7QUFDTSxNQUFPLGlDQUFrQyxTQUFRQSx5QkFBZ0IsQ0FBQTtJQUdyRSxXQUFZLENBQUEsR0FBUSxFQUFFLE1BQXFDLEVBQUE7QUFDekQsUUFBQSxLQUFLLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDOztLQUVwQjtJQUVELE9BQU8sR0FBQTtBQUNMLFFBQUEsSUFBSSxFQUFFLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUMzQixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFcEIsSUFBSUMsZ0JBQU8sQ0FBQyxXQUFXLENBQUM7YUFDckIsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUN4QixhQUFBLE9BQU8sQ0FDTixDQUFvRixpRkFBQSxFQUFBLGdCQUFnQixDQUFDLFlBQVksR0FBRyxDQUNySDtBQUNBLGFBQUEsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUk7YUFDcEIsY0FBYyxDQUFDLFdBQVcsQ0FBQzthQUMzQixRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO0FBQzNDLGFBQUEsUUFBUSxDQUFDLENBQU8sS0FBSyxLQUFJLFNBQUEsQ0FBQSxJQUFBLEVBQUEsS0FBQSxDQUFBLEVBQUEsS0FBQSxDQUFBLEVBQUEsYUFBQTtBQUN4QixZQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksZ0JBQWdCLENBQUMsWUFBWSxDQUFDO0FBQ2xGLFlBQUEsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ2xDLENBQUEsQ0FBQyxDQUNILENBQUM7UUFFSixJQUFJQSxnQkFBTyxDQUFDLFdBQVcsQ0FBQzthQUNyQixPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3RCLGFBQUEsT0FBTyxDQUNOLENBQTRGLHlGQUFBLEVBQUEsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLENBQzNIO0FBQ0EsYUFBQSxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSTthQUNwQixjQUFjLENBQUMsYUFBYSxDQUFDO2FBQzdCLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7QUFDekMsYUFBQSxRQUFRLENBQUMsQ0FBTyxLQUFLLEtBQUksU0FBQSxDQUFBLElBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxhQUFBO0FBQ3hCLFlBQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLENBQUM7QUFDOUUsWUFBQSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDbEMsQ0FBQSxDQUFDLENBQ0gsQ0FBQzs7S0FFTDtBQUNGOztBQzlDb0IsTUFBQSx1QkFBd0IsU0FBUUMsZUFBTSxDQUFBO0FBQTNELElBQUEsV0FBQSxHQUFBOztRQXdCRSxJQUFhLENBQUEsYUFBQSxHQUFHLE1BQVcsU0FBQSxDQUFBLElBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxhQUFBO1lBQ3pCLE1BQU0sS0FBSyxHQUFZLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFFekQsWUFBQSxJQUFJLFNBQVMsQ0FDWCxJQUFJLENBQUMsR0FBRyxFQUNSLEtBQUssRUFDTCxJQUFJLENBQUMsUUFBUSxDQUNkLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDWCxTQUFDLENBQUEsQ0FBQztLQVNIO0lBdENPLE1BQU0sR0FBQTs7QUFDVixZQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsOENBQThDLENBQUMsQ0FBQztBQUU1RCxZQUFBLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUUzRSxZQUFBQyxnQkFBTyxDQUNMLFFBQVEsRUFDUixDQUFBLDR2QkFBQSxDQUE4dkIsQ0FDL3ZCLENBQUM7WUFFRixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFNUUsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUNkLGdCQUFBLEVBQUUsRUFBRSwyQkFBMkI7QUFDL0IsZ0JBQUEsSUFBSSxFQUFFLDhCQUE4QjtnQkFDcEMsUUFBUSxFQUFFLElBQUksQ0FBQyxhQUFhO0FBQzdCLGFBQUEsQ0FBQyxDQUFDO0FBRUgsWUFBQSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksaUNBQWlDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQzNFLENBQUEsQ0FBQTtBQUFBLEtBQUE7SUFZRCxRQUFRLEdBQUE7QUFDTixRQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0RBQWdELENBQUMsQ0FBQztLQUMvRDtJQUVLLFlBQVksR0FBQTs7WUFDaEIsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNwQyxDQUFBLENBQUE7QUFBQSxLQUFBO0FBQ0YsQ0FBQTtBQUVEO0FBQ0EsTUFBTSxTQUFVLFNBQVFDLGNBQUssQ0FBQTtBQUszQixJQUFBLFdBQUEsQ0FDRSxHQUFRLEVBQ1IsS0FBYyxFQUNkLFFBQXlDLEVBQUE7UUFFekMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBUkwsSUFBSyxDQUFBLEtBQUEsR0FBWSxFQUFFLENBQUM7QUFTMUIsUUFBQSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixRQUFBLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0tBQzFCO0lBRUQsTUFBTSxHQUFBOztBQUdKOzs7Ozs7Ozs7Ozs7Ozs7QUFlRTs7UUFHRixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7S0FDbEI7SUFFRCxtQkFBbUIsR0FBQTtBQUNqQixRQUFBLFFBQVEsQ0FBQyxhQUFhLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUM7S0FDN0Y7SUFFRCxTQUFTLEdBQUE7O1FBRVAsTUFBTSxTQUFTLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsQ0FBaUMsOEJBQUEsRUFBQSxTQUFTLEVBQUUsQ0FBQzs7QUFHeEUsUUFBQSxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEdBQUcsRUFBRSx1QkFBdUIsRUFBRSxDQUFDLENBQUM7QUFDbEYsUUFBQSxjQUFjLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRTtBQUNoQyxZQUFBLElBQUksRUFBRSxtQ0FBbUM7QUFDMUMsU0FBQSxDQUFDLENBQUM7QUFDSCxRQUFBLGNBQWMsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO0FBQzlCLFlBQUEsR0FBRyxFQUFFLHlCQUF5QjtBQUM5QixZQUFBLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVk7QUFDakMsU0FBQSxDQUFDLENBQUM7QUFDSCxRQUFBLE1BQU0scUJBQXFCLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDekQsWUFBQSxJQUFJLEVBQUUsMEJBQTBCO0FBQ2pDLFNBQUEsQ0FBQyxDQUFDO0FBQ0gsUUFBQSxxQkFBcUIsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQyxDQUFDOztBQUd2RixRQUFBLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FBQzs7QUFHdkUsUUFBQSxNQUFNLHVCQUF1QixHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO0FBQzNELFlBQUEsSUFBSSxFQUFFLDRCQUE0QjtBQUNuQyxTQUFBLENBQUMsQ0FBQztBQUNILFFBQUEsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQzs7QUFHbEYsUUFBQSxNQUFNLHlCQUF5QixHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO0FBQzdELFlBQUEsSUFBSSxFQUFFLDhCQUE4QjtBQUNyQyxTQUFBLENBQUMsQ0FBQztBQUNILFFBQUEseUJBQXlCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQztLQUN2Rjs7SUFHRCx3QkFBd0IsR0FBQTs7UUFHdEIsSUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQzs7QUFHN0gsUUFBQSxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxHQUFHLE1BQUs7QUFDMUMsWUFBQSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsY0FBYyxFQUFFLElBQUksZ0JBQWdCLENBQUMsWUFBWSxDQUFDO1lBQzVHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0FBQzdCLFNBQUMsQ0FBQTs7QUFFRCxRQUFBLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUNyQzs7SUFHRCxpQkFBaUIsR0FBQTtBQUNmLFFBQUEsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNyQixRQUFBLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDL0IsUUFBQSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBRXpCLFFBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUV6QixRQUFBLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO0FBRTFDLFFBQUEsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLFVBQVUsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDMUUsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3hELFFBQUEsTUFBTSxRQUFRLEdBQUcsQ0FBQSxFQUFHLFVBQVUsQ0FBb0IsaUJBQUEsRUFBQSxHQUFHLE1BQU0sQ0FBQztBQUU1RCxRQUFBLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFFMUIsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDOztBQUdkLFFBQUEsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEMsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ3BDLFNBQUE7UUFDRCxJQUFJLElBQUksSUFBSSxDQUFDO0FBRWIsUUFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxJQUFJLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7QUFDbkMsWUFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbEMsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM3RSxnQkFBQSxJQUFJLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUM7b0JBQ1AsSUFBSSxJQUFJLE1BQU0sQ0FBQztBQUNsQixhQUFBO1lBQ0QsSUFBSSxJQUFJLElBQUksQ0FBQztBQUNkLFNBQUE7QUFDRCxRQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLEdBQUcsTUFBTSxDQUFDLENBQUM7QUFDNUMsUUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xCLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUVqQyxRQUFBLElBQUlDLGVBQU0sQ0FBQyxDQUFBLDRCQUFBLEVBQStCLFFBQVEsQ0FBQSxDQUFFLENBQUMsQ0FBQztLQUV2RDs7OztJQU1ELG1CQUFtQixHQUFBO0FBQ2pCLFFBQUEsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNyQixRQUFBLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDL0IsUUFBQSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBRXpCLFFBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUV6QixRQUFBLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO0FBRTFDLFFBQUEsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLFVBQVUsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDMUUsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3hELFFBQUEsTUFBTSxRQUFRLEdBQUcsQ0FBQSxFQUFHLFVBQVUsQ0FBc0IsbUJBQUEsRUFBQSxHQUFHLE1BQU0sQ0FBQztBQUU5RCxRQUFBLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFFMUIsUUFBQSxJQUFJQSxlQUFNLENBQUMsQ0FBQSw4QkFBQSxFQUFpQyxRQUFRLENBQUEsQ0FBRSxDQUFDLENBQUM7QUFFeEQsUUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixHQUFHLE1BQU0sQ0FBQyxDQUFDOzs7QUFLNUMsUUFBQSxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBRXhCLFFBQUEsU0FBZSxvQkFBb0IsR0FBQTs7O0FBR2pDLGdCQUFBLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0FBQzFDLGdCQUFBLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7O2dCQUduQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzs7Z0JBRzlELE1BQU0sVUFBVSxHQUFlLEVBQUUsQ0FBQzs7QUFHbEMsZ0JBQUEsS0FBSyxNQUFNLENBQUMsSUFBSSxRQUFRLEVBQUU7QUFDeEIsb0JBQUEsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QixNQUFNLE9BQU8sR0FBRyxNQUFNLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzdDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDOUMsb0JBQUEsTUFBTSxTQUFTLEdBQUcsV0FBVyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztBQUd2RCxvQkFBQSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3hELGlCQUFBO0FBRUQsZ0JBQUEsT0FBTyxVQUFVLENBQUM7YUFDbkIsQ0FBQSxDQUFBO0FBQUEsU0FBQTs7O0FBS0QsUUFBQSxTQUFlLElBQUksR0FBQTs7QUFFakIsZ0JBQUEsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7O0FBR3REOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkU7O2dCQUdGLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQzs7QUFHZCxnQkFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEMsSUFBSSxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ3BDLGlCQUFBO2dCQUNELElBQUksSUFBSSxJQUFJLENBQUM7QUFFYixnQkFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDO0FBQ25DLG9CQUFBLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2xDLHdCQUFBLElBQUksT0FBTyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDdkcsSUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzlELElBQUksQ0FBQyxHQUFHLENBQUM7NEJBQ1AsSUFBSSxJQUFJLE1BQU0sQ0FBQztBQUNsQixxQkFBQTtvQkFDRCxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ2QsaUJBQUE7QUFDRCxnQkFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsQixHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDbEMsQ0FBQSxDQUFBO0FBQUEsU0FBQTtBQUVELFFBQUEsSUFBSSxFQUFFLENBQUM7O0tBSVI7SUFFRCxPQUFPLEdBQUE7QUFDTCxRQUFBLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDekIsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ25CO0FBQ0YsQ0FBQTtBQUVELE1BQU0sb0JBQXFCLFNBQVFELGNBQUssQ0FBQTtBQUt0QyxJQUFBLFdBQUEsQ0FBWSxHQUFRLEVBQUUsWUFBb0IsRUFBRSxZQUFvQixFQUFBO1FBQzlELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNYLFFBQUEsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDakMsUUFBQSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztLQUNsQztJQUVELE1BQU0sR0FBQTtBQUNKLFFBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsc0JBQXNCLENBQUE7QUFFakQsUUFBQSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDOztRQUc3QixPQUFPLENBQUMsU0FBUyxHQUFHLENBQUE7OztBQUdRLDhCQUFBLEVBQUEsSUFBSSxDQUFDLFlBQVksQ0FBQTs7O0tBRzVDLENBQUM7O0FBR0YsUUFBQSxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztBQUV6QyxRQUFBLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztRQUdwQyxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2pELFFBQUEsYUFBYSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDakMsYUFBYSxDQUFDLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUMvQyxRQUFBLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDcEM7SUFFTyxTQUFTLEdBQUE7O0FBR2YsUUFBQSxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQzs7QUFHNUMsUUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDOztRQUdoRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDZDtJQUVELGNBQWMsR0FBQTtRQUNaLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztLQUMxQjtBQUNGOzs7OyJ9
